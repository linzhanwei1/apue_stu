# apue_stu

## APUE第一版的学习笔记

## 文件和目录
### 4.3 文件类型
- 普通文件(regular file):最常见的文件类型，这种文件包含了某种形式的数据。至于这种数据是文本还是二进制数据对于内核而言并无区别。对普通文件内容的解释由处理该文件的应用程序进行。
- 目录文件(directory file)。这种文件包含了其他文件的名字以及指向与这些文件有关信息的指针。对一个目录文件具有读许可权的任一进程都可以读该目录的内容，但只有内核可以写目录文件。
- 字符特殊文件(character special file)。这种文件用于系统中某些类型的设备。
- 块特殊文件(block special file)。这种文件典型地用于磁盘设备。系统中所有设备或者是字符特殊文件，或者是块特殊文件。
- FIFO。这种文件用于进程间的通信，有时也将其称为命名管道。
- 套接字(socket)。这种文件用于进程间的网络通信。套接口也可用于在一台宿主机上的进程之间的非网络通信。
- 符号连接(symbolic link)。这种文件指向另一个文件。
### 4.4 设置-用户-ID和设置-组-ID
- 实际用户ID和实际组ID标识我们究竟是谁。这两个字段在登录时取自口令文件中的登录项。
- 有效用户ID，有效组ID以及添加组ID决定了我们的文件访问权。
- 保存的设置-用户-ID和设置-组-ID在执行一个程序时包含了有效用户ID和有效组ID的副本。
### 4.11 chown,fchown和lchown函数
### 4.12 文件长度
- stat结构的成员st_size包含了以字节为单位的该文件的长度。此字段值对普通文件、目录文件和符号连接有意义。
### 4.14 文件系统
- 每个i节点中都有一个连接计数，其值是指向该i节点的目录项数。只有当连接计数减少为0时，才可删除该文件。
- 另外一种连接类型称为(symbolic link)。对于这种连接，该文件的实际内容(在数据块中)包含了该符号链接所指向的文件的名字。
- i节点包含了所有与文件有关的信息:文件类型、文件存取许可权位、文件长度和指向该文件所占用的数据块指针等。
- 因为目录项中的i节点编号数指向同一文件系统中的i节点，所以不能使一个目录项指向另一个文件系统的i节点。
- 当在不更改文件系统的情况下为一个文件更名时，该文件的实际内容并未一种，只需构造一个指向现存i节点的新目录项，并删除老的目录项。
### 4.16 符号连接
- 符号连接是对一个文件的间接指针，与硬连接不同，硬连接直接指向文件的i节点。
- 引进符号连接的原因是为了避免硬连接的一些限制
    - 硬连接通常要求连接和文件位于同一文件系统中，
    - 只有超级用户才能创建到目录的硬连接。
    - 对符号连接以及它指向什么没有文件系统限制，任何用户都可创建指向目录的符号连接。符号连接一般用于将一个文件或整个目录结构移到系统中其他某个位置。
### 4.18 文件的时间
- 每个文件保持有三个时间字段
    1. st_atime 文件数据的最后存取时间 read
    2. st_mtime 文件数据的最后修改时间 write
    3. st_ctime i节点状态的最后更改时间 chmod,chown
### 特殊设备文件
- 每个文件系统都由其主、次设备号而为人所知。设备号所用的数据类型是基本系统数据类型dev_t;
- 通常可以使用两个宏:major和minor来存取主、次设备号。这就意味着我们无需关心这两个数是如何存放在dev_t对象中的；
- 系统中每个文件名的st_dev值是文件系统的设备号，该文件系统包含了该文件名和其对应的i节点
- 只有字符特殊文件和块特殊文件才有st_rdev。此值包含该设备实际设备的设备号。
## 标准I/O库
### 5.4缓存
- 全缓存：当填满标准I/O缓存后才进行实际I/O操作。对于驻在磁盘上的文件通常是由标准I/O库实施全缓存的。术语(flush)说明标准I/O缓存的写操作。缓存可由标准I/O例程自动地刷新(例如当填满一个缓存时)。在终端驱动程序方面，刷新标识丢弃已存在缓存中的数据；
- 行缓存：当在输入和输出中遇到新行符时，标准I/O库执行I/O操作。这允许我们一次输出一个字符(用标准I/Ofputc函数)，但只有在写了一行之后才进行实际I/O操作。当流涉及一个终端时(例如标准输入和标准输出)，典型地使用行缓存。行缓存有2个限制：
    1. 因为标准I/O库用来手机每一行的缓存的长度是固定的，所以只要填满了缓存，那么即使还没有写一个新行符，也进行I/O操作；
    2. 任何时候只要通过标准输入输出库要求从(a)一个不带缓存的流，或者(b)一个行缓存的流(它预先要求从内核得到数据)得到输入数据，那么就会造成刷新所有行缓存输出流。
- 不带缓存：标准I/O库不对字符进行缓存。如果用标准I/O函数写若干字符到不带缓存的流中，则相当于用write系统调用函数将这些字符写至相关联的打开文件上。标准错误流stderr通常是不带缓存的，这就使得出错误信息尽快显示出来，而不管它们是否含有一个新行字符。
### 5.6读和写流
- 一旦打开了流，则可在三种不同类型的非格式化I/O中进行选择，对其进行读、写操作。
    1. 每一次字符的I/O。一次读或写一个字符，如果流是带缓存的，则标准I/O函数处理所有缓存；
    2. 每次一行的I/O。使用fgets和fputs一次读或写一行。每行都以一个新行符终止。当调用fgets时，应说明能处理的最大行长。
    3. 直接I/O。fread和fwrite函数支持这种类型的I/O。每次I/O操作读写或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中读或写一个结构。
## 系统数据文件和信息
## UNIX进程的环境
### 7.3进程终止
1. 正常终止：
    - 从main返回
    - 调用exit
    - 调用_exit
2. 异常终止：
    - 调用abort
    - 由一个信号终止
### 7.4命令行参数分析
- getopt()
- getopt_long()
### 7.6 C程序的存储空间布局
- 代码段：这是由CPU执行的机器指令部分。通常，代码段是可共享的，所以即使是经常执行的程序(如文本编辑程序、C编译程序、shell等)在存储器中也只需有一个副本，另外，代码段常常是只读的，以防止程序由于意外事故而修改其自身的指令。
- 初始化数据段：通常此段称为数据段，它包含了程序中需赋初值的变量。
- 未初始化数据段：也叫BSS段，在程序开始执行之前，内核将此段初始化为0。
- 栈。自动变量以及每次函数调用时所需保存的信息都放在此段中。
- 堆。通常在堆中进行动态存储分配。
### 7.11 getrlimit和setrlimit函数
- 在更改资源限制时，必须遵循下列三条规则:
    1. 任何一个进程都将一个软限制更改为小于或等于其硬限制；
    2. 任何一个进程都可降低其硬限制值，但它必须大于或等于其软限制值。这种降低，对普通用户而言是不可逆的；
    3. 只有超级用户可以提高硬限制。
## 进程控制
### 8.3 fork函数
- fork后父子进程的区别：
    1. fork的返回值不一样，pid不同，ppid也不同；
    2. 未决信号和文件锁不继承，资源利用量清0；
### 8.4 vfork函数(现代操作系统fork已经具备写时拷贝能力，所以vfork使用不多了)
- vfork函数的调用序列和返回值与fork相同，但两者的语义不同：
    1. vfork用于创建一个新进程，而该新进程的目的是exec一个新程序。vfork与fork一样都创建一个子进程，但是它并不将父进程的地址空间完全赋值到子进程中，在子进程调用exec或exit之前，它在父进程的空间中运行。
    2. vfork和fork之间的另一个区别是：vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。
### 8.5 exit函数
- 进程有三种正常终止法及两种异常终止法。
1. 正常终止：
    - 在main函数内执行return语句(return 到父进程看 echo $?)。
    - 调用exit函数。其操作包括调用各终止处理程序(终止处理程序在调用atexit函数时登录)，然后关闭所有标准I/O流等。
    - 调用_exit或_Exit系统调用函数。此函数由exit调用，它处理UNIX特定的细节
    - 最后一个线程从其启动例程返回
    - 最后一个线程调用pthread_exit
2. 异常终止：
    - 调用abort。它产生SIGABRT信号，所以是下一种异常终止的一种特例；
    - 当进程接收到某个信号时。进程本身(例如调用abort函数)、其他进程和内核都能产生传送到某一进程的信号。
    - 最后一个线程对其取消请求做出响应
- 不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它使用的存储器等。
### 8.6 wait和waitpid函数
- 当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。因为子进程终止是个异步事件，所以这种信号也是内核向父进程发的异步通知。父进程可以忽略该信号，或者提供一个该信号发生时即被调用的执行函数(信号处理程序)。对于这种信号的系统默认动作是忽略它。
- 调用wait或waitpid的进程可能会:
    - 阻塞(如果其所有子进程都还在运行)
    - 带子进程的终止状态立即返回；
    - 出错立即返回(如果没有任何子进程).
## 信号

### 10.6 可重入函数
- 所有的系统调用都是可重入的，一部分库函数也是可重入的。
### 信号的响应过程
- 信号从收到到响应有一个不可避免地延迟
- mask & pending
- 标准信号地响应没有严格地顺序
